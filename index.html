<!DOCTYPE html>
<html>
<head>
  <title>Smart Goggles ‚Äì Clean UI</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <!-- TensorFlow for obstacle detection -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
  <!-- Leaflet for map display -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      background: #0a0f1e;
      color: #e0e7ff;
      font-family: 'Inter', -apple-system, system-ui, sans-serif;
      text-align: center;
      padding: 16px;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h2 {
      font-weight: 500;
      letter-spacing: 1px;
      margin-bottom: 16px;
      color: #a5f3fc;
      text-shadow: 0 0 8px #22d3ee33;
    }
    .card {
      background: #1e293b80;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid #334155;
      border-radius: 32px;
      padding: 24px 20px;
      width: 100%;
      max-width: 700px;
      box-shadow: 0 20px 40px -20px #00000080;
    }
    #status {
      background: #0f172a;
      border-radius: 60px;
      padding: 12px 24px;
      margin: 20px 0;
      font-size: 1.1rem;
      font-weight: 500;
      border: 1px solid #2d3a4e;
      color: #b0cdf4;
    }
    .button-group {
      display: flex;
      gap: 12px;
      justify-content: center;
      flex-wrap: wrap;
      margin: 20px 0 10px;
    }
    button {
      background: #1e293b;
      border: 1.5px solid #38bdf8;
      color: #38bdf8;
      padding: 12px 28px;
      border-radius: 60px;
      font-weight: 600;
      font-size: 1.1rem;
      cursor: pointer;
      transition: all 0.15s;
      box-shadow: 0 4px 12px #00000040;
      min-width: 120px;
    }
    button:active { transform: scale(0.96); }
    button:disabled {
      opacity: 0.4;
      border-color: #64748b;
      color: #94a3b8;
      pointer-events: none;
    }
    button#startBtn {
      background: #0f172a;
      border-color: #4ade80;
      color: #4ade80;
    }
    button#stopBtn {
      border-color: #f87171;
      color: #f87171;
    }
    .container {
      position: relative;
      display: inline-block;
      margin: 20px 0 10px;
      border-radius: 24px;
      overflow: hidden;
      box-shadow: 0 0 0 2px #38bdf8, 0 20px 30px -10px black;
    }
    video, canvas {
      display: block;
      background: #0f172a;
      width: 100%;
      height: auto;
    }
    canvas { position: absolute; top: 0; left: 0; }
    #map {
      height: 200px;
      width: 100%;
      max-width: 600px;
      margin: 20px auto 0;
      border-radius: 24px;
      border: 2px solid #38bdf8;
      display: none;
    }
    .hint {
      color: #94a3b8;
      font-size: 0.9rem;
      margin-top: 12px;
      background: #1e293b60;
      padding: 10px 20px;
      border-radius: 60px;
      backdrop-filter: blur(4px);
    }
    .note {
      color: #fcd34d;
      margin: 8px 0;
    }
  </style>
</head>
<body>
  <h2>üï∂Ô∏è Smart Goggles ¬∑ obstacle & navigation</h2>
  <div class="card">
    <div id="status">‚è≥ loading AI model...</div>

    <div class="button-group">
      <button id="cmdBtn">üé§ command</button>
      <button id="startBtn" disabled>‚ñ∂ start camera</button>
      <button id="stopBtn" disabled>‚èπ stop</button>
    </div>

    <div class="container">
      <video id="video" width="480" height="360" playsinline></video>
      <canvas id="canvas" width="480" height="360"></canvas>
    </div>

    <div class="hint" id="permissionHint">
      ‚ÑπÔ∏è tap <strong>start camera</strong> to enable vision & GPS
    </div>
  </div>

  <div id="map"></div>

  <script>
    // ========== CONFIG (replace with your keys) ==========
    const OPENWEATHER_API_KEY = 'YOUR_OPENWEATHER_API_KEY';
    const OPENROUTESERVICE_KEY = 'YOUR_OPENROUTESERVICE_API_KEY';
    // ======================================================

    let model = null;
    let stream = null;
    let running = false;
    let lastDirection = '';
    let detectTimeout = null;
    const speech = window.speechSynthesis;

    // navigation state
    let currentPosition = null;
    let currentHeading = 0;
    let destination = null;
    let route = null;
    let map = null;
    let marker = null;
    let polyline = null;

    // UI elements
    const statusEl = document.getElementById('status');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const cmdBtn = document.getElementById('cmdBtn');
    const permissionHint = document.getElementById('permissionHint');
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // ---------- speech ----------
    function speak(text) {
      console.log('üîä', text);
      statusEl.innerText = text;
      if (speech.speaking) speech.cancel();
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.rate = 1.0;
      utterance.pitch = 1.0;
      utterance.volume = 0.9;
      speech.speak(utterance);
    }

    // ---------- voice command ----------
    function listenForCommand() {
      const recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
      recognition.lang = 'en-US';
      recognition.interimResults = false;
      speak('üé§ listening...');
      recognition.start();

      recognition.onresult = (e) => {
        const cmd = e.results[0][0].transcript.toLowerCase();
        processVoiceCommand(cmd);
      };
      recognition.onerror = () => speak('Sorry, command not understood.');
    }

    function processVoiceCommand(cmd) {
      if (cmd.includes('where am i')) announceLocation();
      else if (cmd.includes('weather')) fetchWeather();
      else if (cmd.includes('navigate to')) {
        let dest = cmd.replace('navigate to', '').trim() || 'Times Square';
        geocodeDestination(dest);
      } else if (cmd.includes('stop navigation')) stopNavigation();
      else speak('Try "where am I", "weather", or "navigate to ..."');
    }

    // ---------- GPS ----------
    function initGPS() {
      if (!navigator.geolocation) { speak('Geolocation not supported.'); return; }
      navigator.geolocation.watchPosition(
        (pos) => {
          const { latitude, longitude, heading } = pos.coords;
          currentPosition = { lat: latitude, lng: longitude };
          if (heading !== null && !isNaN(heading)) currentHeading = heading;
          updateMap();
          if (destination && route) giveNavigationInstruction();
        },
        (err) => console.error('GPS error:', err),
        { enableHighAccuracy: true, maximumAge: 1000 }
      );
    }

    // ---------- map (Leaflet) ----------
    function initMap() {
      if (!map) {
        map = L.map('map').setView([0, 0], 15);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: '¬© OpenStreetMap'
        }).addTo(map);
        document.getElementById('map').style.display = 'block';
      }
    }

    function updateMap() {
      if (!currentPosition) return;
      initMap();
      if (marker) marker.remove();
      marker = L.marker([currentPosition.lat, currentPosition.lng]).addTo(map);
      map.panTo([currentPosition.lat, currentPosition.lng]);
      if (polyline) polyline.remove();
      if (route) polyline = L.polyline(route, { color: '#38bdf8' }).addTo(map);
    }

    // ---------- navigation helpers (same as original) ----------
    function geocodeDestination(name) {
      speak(`Searching for ${name}.`);
      fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(name)}`)
        .then(r => r.json())
        .then(data => {
          if (data.length) {
            const { lat, lon, display_name } = data[0];
            destination = { lat: parseFloat(lat), lng: parseFloat(lon) };
            speak(`Destination set to ${display_name.split(',')[0]}.`);
            fetchRoute();
          } else speak('Place not found.');
        })
        .catch(() => speak('Geocoding error.'));
    }

    function fetchRoute() {
      if (!currentPosition || !destination) return;
      const start = `${currentPosition.lng},${currentPosition.lat}`;
      const end = `${destination.lng},${destination.lat}`;
      const url = `https://api.openrouteservice.org/v2/directions/foot-walking?api_key=${OPENROUTESERVICE_KEY}&start=${start}&end=${end}`;
      fetch(url)
        .then(res => res.json())
        .then(data => {
          if (data.features?.length) {
            route = data.features[0].geometry.coordinates.map(c => [c[1], c[0]]);
            updateMap();
            speak('Route found. Starting navigation.');
          } else speak('No route found.');
        })
        .catch(() => speak('Routing service unavailable.'));
    }

    function giveNavigationInstruction() { /* same as original ‚Äì omitted for brevity, but include full logic */ 
      if (!route || route.length < 2 || !currentPosition) return;
      let minDist = Infinity, closestIdx = 0;
      for (let i = 0; i < route.length; i++) {
        const dist = getDistance(currentPosition, { lat: route[i][0], lng: route[i][1] });
        if (dist < minDist) { minDist = dist; closestIdx = i; }
      }
      if (closestIdx >= route.length - 1) { speak('Arrived.'); stopNavigation(); return; }
      const next = { lat: route[closestIdx+1][0], lng: route[closestIdx+1][1] };
      const bearing = calculateBearing(currentPosition, next);
      speak(getDirectionDescription(bearing, currentHeading));
    }

    function getDistance(p1, p2) { /* ... */ 
      const R = 6371e3; const œÜ1 = p1.lat * Math.PI/180; const œÜ2 = p2.lat * Math.PI/180;
      const ŒîœÜ = (p2.lat - p1.lat) * Math.PI/180; const ŒîŒª = (p2.lng - p1.lng) * Math.PI/180;
      const a = Math.sin(ŒîœÜ/2)**2 + Math.cos(œÜ1)*Math.cos(œÜ2)*Math.sin(ŒîŒª/2)**2;
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    }
    function calculateBearing(start, end) { /* ... */
      const lat1 = start.lat * Math.PI/180; const lat2 = end.lat * Math.PI/180;
      const ŒîŒª = (end.lng - start.lng) * Math.PI/180;
      const y = Math.sin(ŒîŒª) * Math.cos(lat2); const x = Math.cos(lat1)*Math.sin(lat2) - Math.sin(lat1)*Math.cos(lat2)*Math.cos(ŒîŒª);
      return (Math.atan2(y, x) * 180/Math.PI + 360) % 360;
    }
    function getDirectionDescription(bearing, heading) { /* ... */
      const diff = (bearing - heading + 360) % 360;
      if (diff < 30) return 'Continue straight.'; if (diff < 120) return 'Slight right.';
      if (diff < 150) return 'Turn right.'; if (diff < 210) return 'Sharp right.';
      if (diff < 195) return 'Turn around.'; if (diff < 240) return 'Sharp left.';
      if (diff < 285) return 'Turn left.'; if (diff < 240)eturn 'Slight left.';
      return 'Continue straight.';
    }
    function stopNavigation() { destination = null; route = null; if(polyline)polyline.remove(); polyline=null; speak('Navigation stopped.'); }

    function fetchWeather() { /* ... */
      if (!currentPosition) { speak('Location unknown.'); return; }
      const { lat, lng } = currentPosition;
      fetch(`https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lng}&appid=${OPENWEATHER_API_KEY}&units=metric`)
        .then(r=>r.json()).then(d=> speak(`Weather: ${d.weather[0].description}, ${d.main.temp}¬∞C`))
        .catch(()=>speak('Weather unavailable.'));
    }
    function announceLocation() {
      if (!currentPosition) speak('Location unknown.');
      else speak(`Latitude ${currentPosition.lat.toFixed(4)}, longitude ${currentPosition.lng.toFixed(4)}.`);
    }

    // ---------- obstacle detection ----------
    async function loadAI() {
      try {
        model = await cocoSsd.load();
        statusEl.innerText = '‚úÖ AI ready ‚Äì tap "start camera"';
        startBtn.disabled = false;
        // try to auto-start (may be blocked)
        autoStartCamera();
      } catch (e) {
        statusEl.innerText = '‚ùå AI failed to load';
      }
    }

    async function autoStartCamera() {
      try {
        await start();
      } catch (err) {
        // auto-start failed, user must tap start button ‚Äì that's fine
        permissionHint.innerHTML = '‚ö†Ô∏è Camera requires a tap ‚Äì press <strong>start camera</strong>';
      }
    }

    async function start() {
      if (running || !model) return;
      try {
        stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
        video.srcObject = stream;
        await video.play();
        running = true;
        stopBtn.disabled = false;
        startBtn.disabled = true;
        permissionHint.innerText = '‚úÖ Camera active ‚Äì obstacle detection running';
        initGPS();               // start GPS after camera success
        detect();                // start detection loop
      } catch (error) {
        statusEl.innerText = 'Camera access denied. Tap start again.';
        startBtn.disabled = false;
      }
    }

    function stop() {
      if (detectTimeout) clearTimeout(detectTimeout);
      running = false;
      lastDirection = '';
      if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
      speech.cancel();
      statusEl.innerText = 'System stopped';
      stopBtn.disabled = true;
      startBtn.disabled = false;
      permissionHint.innerHTML = '‚ÑπÔ∏è tap <strong>start camera</strong> to resume';
      ctx.clearRect(0,0,canvas.width,canvas.height);
    }

    async function detect() {
      if (!running) return;
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      try {
        const predictions = await model.detect(video);
        if (predictions.length) {
          const closest = predictions.reduce((p,c) => (c.bbox[2]*c.bbox[3] > p.bbox[2]*p.bbox[3]) ? c : p);
          const [x, y, w, h] = closest.bbox;
          const centerX = x + w/2;
          let direction = centerX < canvas.width*0.33 ? 'left' : (centerX > canvas.width*0.66 ? 'right' : 'ahead');
          ctx.strokeStyle = '#f87171'; ctx.lineWidth = 3; ctx.strokeRect(x,y,w,h);
          ctx.fillStyle = '#f87171'; ctx.font = 'bold 14px Inter'; 
          ctx.fillText(`${closest.class} ${Math.round(closest.score*100)}%`, x, y>20 ? y-8 : y+18);
          if (direction !== lastDirection) { speak(`‚ö†Ô∏è obstacle ${direction}: ${closest.class}`); lastDirection = direction; }
          statusEl.innerText = `obstacle ${direction}`;
        } else {
          statusEl.innerText = 'path clear';
          lastDirection = '';
        }
      } catch (e) { console.warn('detection error', e); }
      detectTimeout = setTimeout(detect, 500);
    }

    // ---------- event listeners ----------
    cmdBtn.addEventListener('click', listenForCommand);
    startBtn.addEventListener('click', start);
    stopBtn.addEventListener('click', stop);

    // start loading AI immediately
    loadAI();
  </script>
</body>
</html>
